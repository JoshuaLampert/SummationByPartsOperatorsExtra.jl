<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SummationByPartsOperatorsExtra.jl</title><meta name="title" content="Reference · SummationByPartsOperatorsExtra.jl"/><meta property="og:title" content="Reference · SummationByPartsOperatorsExtra.jl"/><meta property="twitter:title" content="Reference · SummationByPartsOperatorsExtra.jl"/><meta name="description" content="Documentation for SummationByPartsOperatorsExtra.jl."/><meta property="og:description" content="Documentation for SummationByPartsOperatorsExtra.jl."/><meta property="twitter:description" content="Documentation for SummationByPartsOperatorsExtra.jl."/><meta property="og:url" content="https://JoshuaLampert.github.io/SummationByPartsOperatorsExtra.jl/stable/ref/"/><meta property="twitter:url" content="https://JoshuaLampert.github.io/SummationByPartsOperatorsExtra.jl/stable/ref/"/><link rel="canonical" href="https://JoshuaLampert.github.io/SummationByPartsOperatorsExtra.jl/stable/ref/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperatorsExtra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../development/">Development</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/main/docs/src/ref.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SummationByPartsOperatorsExtra.jl-API"><a class="docs-heading-anchor" href="#SummationByPartsOperatorsExtra.jl-API">SummationByPartsOperatorsExtra.jl API</a><a id="SummationByPartsOperatorsExtra.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#SummationByPartsOperatorsExtra.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.SummationByPartsOperatorsExtra" href="#SummationByPartsOperatorsExtra.SummationByPartsOperatorsExtra"><code>SummationByPartsOperatorsExtra.SummationByPartsOperatorsExtra</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SummationByPartsOperatorsExtra</code></pre><p><strong>SummationByPartsOperatorsExtra.jl</strong> is a <a href="https://julialang.org/">Julia</a> package that implements some extra functionality for the package <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a>. SummationByPartsOperatorsExtra.jl is still in an early stage of development and is meant to be used for research purposes. Maybe some parts of the package will be moved to SummationByPartsOperators.jl in the future. Until now, the package focuses on the implementation of function space summation-by-parts operators in one and multiple dimensions and on subcell summation-by-parts operators.</p><p>See also: <a href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl">SummationByPartsOperatorsExtra.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/SummationByPartsOperatorsExtra.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2025" href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2025"><code>SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2025</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GlaubitzIskeLampertÖffner2025()</code></pre><p>Multidimensional function space SBP (MFSBP) operators given in</p><ul><li>Glaubitz, Iske, Lampert, Öffner (2025) Efficient construction and application of multi-dimensional summation-by-parts operators to global radial basis function methods TODO</li></ul><p>See <a href="#SummationByPartsOperatorsExtra.multidimensional_function_space_operator"><code>multidimensional_function_space_operator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/multidimensional_function_space_operators.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.GlaubitzLampertNordströmWinters2025" href="#SummationByPartsOperatorsExtra.GlaubitzLampertNordströmWinters2025"><code>SummationByPartsOperatorsExtra.GlaubitzLampertNordströmWinters2025</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GlaubitzLampertNordströmWinters2025()</code></pre><p>Sub-cell SBP operators given in</p><ul><li>Glaubitz, Lampert, Nordström, Winters (2025): Provable energy stable overset grid methods using sub-cell summation-by-parts operators: One-dimensional linear advection equations. TODO</li></ul><p>See <a href="#SummationByPartsOperatorsExtra.subcell_operator"><code>subcell_operator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L280-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.SubcellOperator" href="#SummationByPartsOperatorsExtra.SubcellOperator"><code>SummationByPartsOperatorsExtra.SubcellOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SubcellOperator{T}
SubcellOperator(nodes::Vector{T}, x_M::T,
                weights_left::Vector{T}, weights_right::Vector{T},
                Q_left::QType, Q_right::QType,
                B_left::BType, B_right::BType,
                accuracy_order::Int,
                source::SourceOfCoefficients) where {T &lt;: Real,
                                                     QType &lt;: AbstractMatrix{T},
                                                     BType &lt;: AbstractMatrix{T},
                                                     SourceOfCoefficients}</code></pre><p>A sub-cell derivative operator on a non-periodic grid with scalar type <code>T</code>. A sub-cell operator consists of two parts, a left and a right part, which are defined on the left and right sub-cells of the grid. Each of the two parts satisfy a summation-by-parts property on their respecting sub-cell. The whole operator satisfies a summation-by-parts property on the whole grid.</p><p>The whole operator follows the general interface of a derivative operator, e.g., implementing matrix-vector multiplication, integration, and the mass matrix. To obtain the derivative matrix <span>$D = P^{-1}(Q_L + Q_R)$</span> associated to the sub-cell operator, use the function <a href="#SummationByPartsOperatorsExtra.derivative_matrix-Tuple{SubcellOperator}"><code>derivative_matrix</code></a>. The left and right mass matrices can be obtained with the functions <a href="#SummationByPartsOperatorsExtra.mass_matrix_left-Tuple{SubcellOperator}"><code>mass_matrix_left</code></a> and <a href="#SummationByPartsOperatorsExtra.mass_matrix_right-Tuple{SubcellOperator}"><code>mass_matrix_right</code></a>, respectively. Similarly, the boundary mass matrices can be obtained with the functions <a href="#SummationByPartsOperatorsExtra.mass_matrix_boundary_left-Tuple{SubcellOperator}"><code>mass_matrix_boundary_left</code></a> and <a href="#SummationByPartsOperatorsExtra.mass_matrix_boundary_right-Tuple{SubcellOperator}"><code>mass_matrix_boundary_right</code></a>.</p><p>See also <a href="#SummationByPartsOperatorsExtra.subcell_operator"><code>subcell_operator</code></a> and <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2025"><code>GlaubitzIskeLampertÖffner2025</code></a>.</p><p>References:</p><ul><li>Glaubitz, Lampert, Nordström, Winters (2025): Provable energy stable overset grid methods using sub-cell summation-by-parts operators: One-dimensional linear advection equations. TODO</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.compute_moments_boundary-Tuple{Any, Any, Any}" href="#SummationByPartsOperatorsExtra.compute_moments_boundary-Tuple{Any, Any, Any}"><code>SummationByPartsOperatorsExtra.compute_moments_boundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_moments_boundary(functions, nodes, normals)
compute_moments_boundary(functions, D::AbstractDerivativeOperator)
compute_moments_boundary(functions, geometry::Meshes.Geometry)</code></pre><p>Compute the moments, i.e., the integrals of the product of two basis functions weighted by the normal direction of the direction. For each direction, it computes a <span>$K 	imes K$</span> matrix, where <span>$K$</span> is the number of <code>functions</code> and returns a tuple of these matrices. In one dimension, <code>nodes</code> and <code>normals</code> can be passed. You can also pass a derivative operator <code>D</code> or a <code>Geometry</code> object from Meshes.jl. Note that the latter is defined in a package extension of MeshIntegrals.jl and therefore requires loading that package before.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/utils/moments.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.derivative_matrix-Tuple{SubcellOperator}" href="#SummationByPartsOperatorsExtra.derivative_matrix-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.derivative_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative_matrix(Dop::SubcellOperator)</code></pre><p>Returns the derivative matrix <span>$D = P^{-1}(Q_L + Q_R)$</span> associated to the sub-cell operator <code>Dop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.function_space_operator" href="#SummationByPartsOperatorsExtra.function_space_operator"><code>SummationByPartsOperatorsExtra.function_space_operator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function_space_operator(basis_functions, nodes, source;
                        derivative_order = 1, accuracy_order = 0,
                        basis_functions_weights = ones(length(basis_functions)),
                        bandwidth = length(nodes) - 1, size_boundary = 2 * bandwidth,
                        different_values = true, sparsity_pattern = nothing,
                        opt_alg = Optim.LBFGS(), options = Optim.Options(g_tol = 1e-14, iterations = 10000),
                        autodiff = :forward, x0 = nothing, verbose = false)</code></pre><p>Construct an operator that represents a first-derivative operator in a function space spanned by the <code>basis_functions</code>, which is an iterable of functions. The operator is constructed on the interval <code>[x_min, x_max]</code> with the nodes <code>nodes</code>, where <code>x_min</code> is taken as the minimal value in <code>nodes</code> and <code>x_max</code> the maximal value. Note that the <code>nodes</code> will be sorted internally. The <code>accuracy_order</code> is the order of the accuracy of the operator, which can optionally be passed, but does not have any effect on the operator.</p><p>The operator is constructed solving an optimization problem with Optim.jl. You can specify the optimization algorithm, the options for the optimization problem, and the <code>autodiff</code> mode with the keyword arguments <code>opt_alg</code>, <code>options</code>, and <code>autodiff</code> respectively, see also the documentation of Optim.jl about <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/">configurable options</a> and <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/gradientsandhessians/#Automatic-differentiation">automatic differentiation</a>. In this case, reverse mode automatic differentiation is usually significantly faster than forward mode. We recommend using <code>autodiff = ADTypes.AutoMooncake(; config = nothing)</code> or <code>autodiff = ADTypes.AutoEnzyme(; mode = Enzyme.Reverse, function_annotation = Enzyme.Duplicated)</code>. Note that you need to import the package <code>ADTypes</code> as well as the corresponding autodiff (i.e., <code>Mooncake</code> or <code>Enzyme</code>) package to use these modes.</p><p>The initial guess for the optimization problem can be passed with the keyword argument <code>x0</code>, which is optional. If <code>nothing</code> is passed, a default initial guess (zeros for the entries of the differentiation matrix and equal values for all the weights) is used.</p><p>You can weight each basis function with the keyword argument <code>basis_functions_weights</code>, which is a vector of weights for each basis function. The default is a vector of ones, which means that all basis functions are equally weighted. This can be used to, e.g., enforce exactness for certain basis functions (high weights), but allow non-exactness for others only minimizing the error (low weights).</p><p>There are two alternative ways to enforce sparsity of the resulting operator. The first is by passing a matrix <code>sparsity_pattern</code> that is a matrix of zeros and ones, where the ones indicate the non-zero entries of the operator. This matrix should be symmetric or <code>UpperTriangular</code> and have zeros on the diagonal.</p><p>The second way is to use a banded-block structure for the operator as is common, e.g., in finite difference methods. The keyword arguments <code>bandwidth</code> and <code>size_boundary</code> specify the bandwidth and the size of the boundary blocks of the operator, where the default of <code>bandwidth</code> is set to <code>length(nodes) - 1</code>, i.e., a dense operator (in this case <code>size_boundary</code> is ignored). To construct a sparse operator, you can set the bandwidth to a smaller value, such that <code>2 * size_boundary + bandwidth &lt; length(nodes)</code>, which is a requirement for the boundary blocks in the upper left and lower right of the resulting operator. If <code>different_values</code> is set to <code>true</code> all the entries in the upper right triangle of S (the skew symmetric part of D) are different, which is generally meaningful for non-equidistant nodes and general bases, if it is <code>false</code> the entries of the stencil are repeated in the central part and the two boundary closures share their values (makes sense for uniformly distributed nodes and, e.g., a polynomial basis). The keyword argument <code>different_values</code> is ignored for dense operators.</p><p>The keyword argument <code>verbose</code> can be set to <code>true</code> to print information about the optimization process.</p><p>The operator that is returned follows the general interface. Currently, it is wrapped in a <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.MatrixDerivativeOperator"><code>SummationByPartsOperators.MatrixDerivativeOperator</code></a>, but this might change in the future. In order to use this function, the package <code>Optim</code> must be loaded.</p><p>See also <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.GlaubitzNordstr%C3%B6m%C3%96ffner2023"><code>SummationByPartsOperators.GlaubitzNordströmÖffner2023</code></a>.</p><div class="admonition is-compat" id="Julia-1.9-f582f86754be828d"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-f582f86754be828d" title="Permalink"></a></header><div class="admonition-body"><p>This function requires at least Julia 1.9.</p></div></div><div class="admonition is-warning" id="Experimental-implementation-2b6ea2882587deda"><header class="admonition-header">Experimental implementation<a class="admonition-anchor" href="#Experimental-implementation-2b6ea2882587deda" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/function_space_operators.jl#L2-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.get_multidimensional_optimization_entries-Tuple{Any}" href="#SummationByPartsOperatorsExtra.get_multidimensional_optimization_entries-Tuple{Any}"><code>SummationByPartsOperatorsExtra.get_multidimensional_optimization_entries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_multidimensional_optimization_entries(D;
                                          bandwidth = div(accuracy_order(D), 2),
                                          size_boundary = SummationByPartsOperators.lower_bandwidth(D) + 1,
                                          different_values = false,
                                          sparsity_pattern = nothing)</code></pre><p>Get the entries to optimize for in an optimization-based construction procedure of multidimensional summation-by-parts operators from a derivative operator <code>D</code>. It contains the entries of the skew-symmetric part of the operator <code>D</code>, the entries of the diagonal mass matrix <code>M</code>, and the entries of the diagonal boundary mass matrix. For more details, see <a href="#SummationByPartsOperatorsExtra.multidimensional_function_space_operator"><code>multidimensional_function_space_operator</code></a>. The output can be passed as initial values to the optimization problem as <code>x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/utils/optimization.jl#L200-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.get_nsigma-Tuple{Any}" href="#SummationByPartsOperatorsExtra.get_nsigma-Tuple{Any}"><code>SummationByPartsOperatorsExtra.get_nsigma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nsigma(N; bandwidth = N - 1,
           size_boundary = 2 * bandwidth, different_values = true,
           sparsity_pattern = nothing)</code></pre><p>Get the number of unique non-zero entries in a skew-symmetric matrix. If <code>bandwidth</code> is <code>N - 1</code>, the whole upper right triangle is used. If <code>bandwidth</code> is smaller, a block-banded structure with boundary blocks of size <code>size_boundary</code> is used and a banded matrix with bandwidth <code>bandwidth</code> in the middle. If <code>different_values</code> is <code>false</code>, the stencils are repeating. If <code>sparsity_pattern</code> is given, the number of non-zero entries in the sparsity pattern is returned. The sparsity pattern is assumed to be a <code>UpperTriangular</code> matrix with zeros on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/utils/optimization.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.get_optimization_entries-Tuple{Any}" href="#SummationByPartsOperatorsExtra.get_optimization_entries-Tuple{Any}"><code>SummationByPartsOperatorsExtra.get_optimization_entries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_optimization_entries(D;
                         bandwidth = div(accuracy_order(D), 2),
                         size_boundary = SummationByPartsOperators.lower_bandwidth(D) + 1,
                         different_values = false,
                         sparsity_pattern = nothing)</code></pre><p>Get the entries to optimize for in an optimization-based construction procedure of summation-by-parts operators from a derivative operator <code>D</code>. It contains the entries of the skew-symmetric part of the operator <code>D</code> and the entries of the diagonal mass matrix <code>M</code>. For more details, see <a href="#SummationByPartsOperatorsExtra.function_space_operator"><code>function_space_operator</code></a>. The output can be passed as initial values to the optimization problem as <code>x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/utils/optimization.jl#L106-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.get_sparsity_pattern-Tuple{Any}" href="#SummationByPartsOperatorsExtra.get_sparsity_pattern-Tuple{Any}"><code>SummationByPartsOperatorsExtra.get_sparsity_pattern</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_sparsity_pattern(S)
get_sparsity_pattern(D::AbstractNonperiodicDerivativeOperator)
get_sparsity_pattern(D::AbstractMultidimensionalMatrixDerivativeOperator{2})</code></pre><p>If <code>S</code> is a (skew-symmetric) matrix, this function returns the sparsity pattern of <code>S</code> as a <code>UpperTriangular</code> matrix. If <code>D</code> is a one-dimensional derivative operator, this function returns the sparsity pattern of the skew-symmetric part of <code>D</code>. If <code>D</code> is a two-dimensional derivative operator, this function returns a tuple of the sparsity patterns of the skew-symmetric parts of <code>D</code> in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/utils/sparsity_patterns.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.grid_left-Tuple{SubcellOperator}" href="#SummationByPartsOperatorsExtra.grid_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.grid_left</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_left(D::SubcellOperator)</code></pre><p>Returns the grid associated to the left part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.grid_right-Tuple{SubcellOperator}" href="#SummationByPartsOperatorsExtra.grid_right-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.grid_right</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_right(D::SubcellOperator)</code></pre><p>Returns the grid associated to the right part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.left_projection_left-Tuple{SubcellOperator}" href="#SummationByPartsOperatorsExtra.left_projection_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.left_projection_left</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_projection_left(D::SubcellOperator)
left_projection_right(D::SubcellOperator)
right_projection_left(D::SubcellOperator)
right_projection_right(D::SubcellOperator)</code></pre><p>Returns the left and right projection operators associated to the left and right parts of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.mass_matrix_boundary_left-Tuple{SubcellOperator}" href="#SummationByPartsOperatorsExtra.mass_matrix_boundary_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.mass_matrix_boundary_left</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mass_matrix_boundary_left(D::SubcellOperator)</code></pre><p>Returns the mass matrix associated to the left boundary of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.mass_matrix_boundary_right-Tuple{SubcellOperator}" href="#SummationByPartsOperatorsExtra.mass_matrix_boundary_right-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.mass_matrix_boundary_right</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mass_matrix_boundary_right(D::SubcellOperator)</code></pre><p>Returns the mass matrix associated to the right boundary of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.mass_matrix_left-Tuple{SubcellOperator}" href="#SummationByPartsOperatorsExtra.mass_matrix_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.mass_matrix_left</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mass_matrix_left(D::SubcellOperator)</code></pre><p>Returns the mass matrix associated to the left part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.mass_matrix_right-Tuple{SubcellOperator}" href="#SummationByPartsOperatorsExtra.mass_matrix_right-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.mass_matrix_right</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mass_matrix_right(D::SubcellOperator)</code></pre><p>Returns the mass matrix associated to the right part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.multidimensional_function_space_operator" href="#SummationByPartsOperatorsExtra.multidimensional_function_space_operator"><code>SummationByPartsOperatorsExtra.multidimensional_function_space_operator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multidimensional_function_space_operator(basis_functions, nodes, boundary_indices, normals, moments, vol, source;
                                         derivative_order = 1, accuracy_order = 0,
                                         bandwidth = length(nodes) - 1, size_boundary = 2 * bandwidth,
                                         different_values = true, sparsity_pattern = nothing,
                                         opt_alg = Optim.LBFGS(), options = Optim.Options(g_tol = 1e-14, iterations = 10000),
                                         autodiff = :forward, x0 = nothing, verbose = false)</code></pre><p>Construct a <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.MultidimensionalMatrixDerivativeOperator"><code>SummationByPartsOperators.MultidimensionalMatrixDerivativeOperator</code></a> that represents a first-derivative operator in a function space spanned by the <code>basis_functions</code>, which is an iterable of functions. The operator is constructed on the scattered nodes <code>nodes</code>. They should be provided as an iterable of <code>SVector{Dim, T}</code>. The <code>boundary_indices</code> is a vector of indies that indicates, which nodes are on the boundary. <code>normals</code> is a vector of <code>SVector{Dim, T}</code> that contains the normal vectors of the boundary nodes. The <code>moments</code> are a <code>Tuple</code> of matrices that represent the moments of the basis functions in each direction. The total volume of the domain is given by <code>vol</code>.</p><p>The <code>accuracy_order</code> is the order of the accuracy of the operator, which can optionally be passed, but does not have any effect on the operator.</p><p>The operator is constructed solving an optimization problem with Optim.jl. You can specify the optimization algorithm, the options for the optimization problem, and the <code>autodiff</code> mode with the keyword arguments <code>opt_alg</code>, <code>options</code>, and <code>autodiff</code> respectively, see also the documentation of Optim.jl about <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/">configurable options</a> and <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/gradientsandhessians/#Automatic-differentiation">automatic differentiation</a>. In this case, reverse mode automatic differentiation is usually significantly faster than forward mode. We recommend using <code>autodiff = ADTypes.AutoMooncake(; config = nothing)</code> or <code>autodiff = ADTypes.AutoEnzyme(; mode = Enzyme.Reverse, function_annotation = Enzyme.Duplicated)</code>. Note that you need to import the package <code>ADTypes</code> as well as the corresponding autodiff (i.e., <code>Mooncake</code> or <code>Enzyme</code>) package to use these modes.</p><p>The initial guess for the optimization problem can be passed with the keyword argument <code>x0</code>, which is optional. If <code>nothing</code> is passed, a default initial guess (zeros for the entries of the differentiation matrix and equal values for all the weights and boundary weights) is used.</p><p>There are two alternative ways to enforce sparsity of the resulting operator. The first is by passing a matrix <code>sparsity_pattern</code> that is a matrix of zeros and ones, where the ones indicate the non-zero entries of the operator. This matrix should be symmetric or <code>UpperTriangular</code> and have zeros on the diagonal.</p><p>The second way is to use a banded-block structure for the operator as is common, e.g., in finite difference methods. The keyword arguments <code>bandwidth</code> and <code>size_boundary</code> specify the bandwidth and the size of the boundary blocks of the differentiation matrices in each direction, where the default of <code>bandwidth</code> is set to <code>length(nodes) - 1</code>, i.e., dense operators (in this case <code>size_boundary</code> is ignored). To construct sparse operators, you can set the bandwidth to a smaller value, such that <code>2 * size_boundary + bandwidth &lt; length(nodes)</code>, which is a requirement for the boundary blocks in the upper left and lower right of the resulting operator. If <code>different_values</code> is set to <code>true</code> all the entries in the upper right triangle of all matrices S (the skew symmetric parts of the differentiation matrices D) are different, which is generally meaningful for non-equidistant nodes and general bases, if it is <code>false</code> the entries of the stencil are repeated in the central part and the two boundary closures share their values (makes sense for uniformly distributed nodes and, e.g., a polynomial basis). The keyword argument <code>different_values</code> is ignored for dense operators. The parameters <code>bandwidth</code>, <code>size_boundary</code>, and <code>different_values</code> are only used if <code>sparsity_pattern</code> is not provided.</p><p>The keyword argument <code>verbose</code> can be set to <code>true</code> to print information about the optimization process.</p><p>In order to use this function, the package <code>Optim</code> must be loaded.</p><p>See also <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2025"><code>GlaubitzIskeLampertÖffner2025</code></a>.</p><div class="admonition is-compat" id="Julia-1.9-f582f86754be828d"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-f582f86754be828d" title="Permalink"></a></header><div class="admonition-body"><p>This function requires at least Julia 1.9.</p></div></div><div class="admonition is-warning" id="Experimental-implementation-2b6ea2882587deda"><header class="admonition-header">Experimental implementation<a class="admonition-anchor" href="#Experimental-implementation-2b6ea2882587deda" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/multidimensional_function_space_operators.jl#L27-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.neighborhood_sparsity_pattern-Tuple{Any, Any}" href="#SummationByPartsOperatorsExtra.neighborhood_sparsity_pattern-Tuple{Any, Any}"><code>SummationByPartsOperatorsExtra.neighborhood_sparsity_pattern</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighborhood_sparsity_pattern(nodes, lengths)</code></pre><p>For a given set of <code>nodes</code> in a multi-dimensional space, this function computes the sparsity pattern of the differentiation matrices, which only includes non-zero entries at nodes, which are within a certain ellipsoid neighborhood. <code>lengths</code> is a tuple of length <code>d</code> (dimension) representing the lengths of an ellipsoid indicating, which nodes are counted as neighbors. For example, for a differentiation matrix in x direction, it makes sense to use a larger length in x direction than in y direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/utils/sparsity_patterns.jl#L37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.plot_nodes" href="#SummationByPartsOperatorsExtra.plot_nodes"><code>SummationByPartsOperatorsExtra.plot_nodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_nodes(nodes_inner, nodes_boundary; corners = nothing, kwargs...)
plot_nodes(nodes, boundary_indices::Vector{Int}; corner_indices = nothing,
           kwargs...)
plot_nodes(D; kwargs...)</code></pre><p>Plot the nodes of a multidimensional derivative operator <code>D</code>. The interior nodes <code>nodes_inner</code> are plotted and the boundary nodes <code>nodes_boundary</code> are plotted in different colors. If <code>corner_indices</code> are provided, the corners are also plotted in a different color. Additional keyword arguments are passed to <code>viz</code> from Meshes.jl, see <a href="https://juliageometry.github.io/MeshesDocs/stable/visualization/">the documentation</a>. The function returns the current figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/utils/visualization.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.plot_normals" href="#SummationByPartsOperatorsExtra.plot_normals"><code>SummationByPartsOperatorsExtra.plot_normals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_normals(nodes_boundary, normals; kwargs...)
plot_normals(D; kwargs...)</code></pre><p>Plot the normals of a multidimensional derivative operator <code>D</code>. The boundary nodes <code>nodes_boundary</code> are plotted and the normals are plotted as arrows. Additional keyword arguments are passed to <code>viz</code> from Meshes.jl, see <a href="https://juliageometry.github.io/MeshesDocs/stable/visualization/">the documentation</a>. The function returns the current figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/utils/visualization.jl#L15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByPartsOperatorsExtra.subcell_operator" href="#SummationByPartsOperatorsExtra.subcell_operator"><code>SummationByPartsOperatorsExtra.subcell_operator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subcell_operator(basis_functions, nodes, x_M, source;
                 derivative_order = 1, accuracy_order = 0,
                 bandwidths = [N_L - 1, N_R - 1], size_boundaries = 2 .* bandwidths,
                 different_values = [true, true], sparsity_patterns = [nothing, nothing],
                 M_local_approximation = [N_L, N_R],
                 opt_alg = Optim.LBFGS(), options = Optim.Options(g_tol = 1e-14, iterations = 10000),
                 autodiff = :forward, x0 = nothing, verbose = false)</code></pre><p>Construct a sub-cell operator in a function space spanned by the <code>basis_functions</code>, which is an iterable of functions. The operator is constructed on the interval <code>[x_min, x_max]</code> with the nodes <code>nodes</code>, where <code>x_min</code> is taken as the minimal value in <code>nodes</code> and <code>x_max</code> the maximal value. Note that the <code>nodes</code> will be sorted internally. The left part of the sub-cell operator consists of the <code>nodes</code>, which are smaller than <code>x_M</code> and the right part of the <code>nodes</code>, which are bigger than <code>x_M</code>. The <code>accuracy_order</code> is the order of the accuracy of the operator, which can optionally be passed, but does not have any effect on the operator.</p><p>The operator is constructed solving an optimization problem with Optim.jl. You can specify the optimization algorithm, the options for the optimization problem, and the <code>autodiff</code> mode with the keyword arguments <code>opt_alg</code>, <code>options</code>, and <code>autodiff</code> respectively, see also the documentation of Optim.jl about <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/">configurable options</a> and <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/gradientsandhessians/#Automatic-differentiation">automatic differentiation</a>. In this case, reverse mode automatic differentiation is usually significantly faster than forward mode. We recommend using <code>autodiff = ADTypes.AutoMooncake(; config = nothing)</code> or <code>autodiff = ADTypes.AutoEnzyme(; mode = Enzyme.Reverse, function_annotation = Enzyme.Duplicated)</code>. Note that you need to import the package <code>ADTypes</code> as well as the corresponding autodiff (i.e., <code>Mooncake</code> or <code>Enzyme</code>) package to use these modes.</p><p>The initial guess for the optimization problem can be passed with the keyword argument <code>x0</code>, which is optional. If <code>nothing</code> is passed, a default initial guess (zeros for the entries of the differentiation matrix and equal values for all the weights) is used.</p><p>There are two alternative ways to enforce sparsity of the resulting left and right operator. The first is by passing matrices <code>sparsity_pattern</code> that are matrices of zeros and ones each, where the ones indicate the non-zero entries of the left and operator, respectively. The matrices should be symmetric or <code>UpperTriangular</code> and have zeros on the diagonal.</p><p>The second way is to use a banded-block structure for the parts of the operator as is common, e.g., in finite difference methods. The keyword arguments <code>bandwidths</code> and <code>size_boundaries</code> specify the bandwidth and the size of the boundary blocks of the operators, where the default of <code>bandwidths</code> is set to the number of nodes in the left and right sub-cell minus one, i.e., a dense operator (in this case <code>size_boundaries</code> is ignored). To construct a sparse operator, you can set the bandwidth to a smaller value, such that <code>2 * size_boundaries[i] + bandwidths[i] &lt; N_{L/R}</code>, which is a requirement for the boundary blocks in the upper left and lower right of the resulting operator. If <code>different_values</code> is set to <code>true</code> all the entries in the upper right triangle of S (the skew symmetric parts of the differentiation matrix blocks) are different, which is generally meaningful for non-equidistant nodes and general bases, if it is <code>false</code> the entries of the stencil are repeated in the central part and the two boundary closures share their values (makes sense for uniformly distributed nodes and, e.g., a polynomial basis). The keyword argument <code>different_values</code> is ignored for dense operators.</p><p>You can use the keyword argument <code>M_local_approximation</code> to specify the number of points used for local approximations of the discrete projections. The default is to use the number of nodes in the left and right sub-cell, respectively. To use an interpolation, you can set <code>M_local_approximation</code> to <code>[K, K]</code>, where <code>K</code> is the number of basis functions.</p><p>The keyword argument <code>verbose</code> can be set to <code>true</code> to print information about the optimization process.</p><p>Returns a <a href="#SummationByPartsOperatorsExtra.SubcellOperator"><code>SubcellOperator</code></a> object.</p><p>See also <a href="#SummationByPartsOperatorsExtra.GlaubitzLampertNordströmWinters2025"><code>GlaubitzLampertNordströmWinters2025</code></a>.</p><div class="admonition is-compat" id="Julia-1.9-f582f86754be828d"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-f582f86754be828d" title="Permalink"></a></header><div class="admonition-body"><p>This function requires at least Julia 1.9.</p></div></div><div class="admonition is-warning" id="Experimental-implementation-2b6ea2882587deda"><header class="admonition-header">Experimental implementation<a class="admonition-anchor" href="#Experimental-implementation-2b6ea2882587deda" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/b7b5fe07e08309720300f8bf360c0a9aa966f6ab/src/subcell_operators.jl#L306-L369">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../development/">« Development</a><a class="docs-footer-nextpage" href="../license/">License »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Sunday 15 June 2025 13:37">Sunday 15 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
