@testsnippet FSBP_Manopt begin
    import Manifolds, Manopt, ForwardDiff
end

@testitem "FSBP with Manopt.jl" setup=[FSBP_Manopt] begin
    N = 5
    x_min = -1.0
    x_max = 1.0
    nodes = collect(range(x_min, x_max, length = N))
    source = GlaubitzIskeLampertÖffner2025()
    for compact in (true, false)
        show(IOContext(devnull, :compact => compact), source)
    end
    let basis_functions = [x -> x^i for i in 0:3]
        D = function_space_operator(basis_functions, nodes, source; verbose = true)
        # Test errors
        @test_throws ArgumentError function_space_operator(basis_functions, nodes,
                                                           source; derivative_order = 2)
        @test_throws ArgumentError function_space_operator(basis_functions, nodes,
                                                           source;
                                                           sparsity_pattern = ones(Bool, N,
                                                                                   N))
        @test_throws ArgumentError function_space_operator(basis_functions, nodes,
                                                           source;
                                                           bandwidth = 2)
        @test_throws ArgumentError function_space_operator(basis_functions, nodes, source;
                                                           x0 = zeros(3))
        @test_throws ArgumentError function_space_operator(basis_functions, nodes, source;
                                                           basis_functions_weights = ones(3))

        @test grid(D) ≈ nodes
        @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-13))
        @test D * nodes ≈ ones(N)
        @test D * (nodes .^ 2) ≈ 2 * nodes
        @test D * (nodes .^ 3) ≈ 3 * (nodes .^ 2)
        M = mass_matrix(D)
        @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
    end

    let basis_functions = [one, identity, exp]
        D = function_space_operator(basis_functions, nodes, source)

        @test grid(D) ≈ nodes
        @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-13))
        @test D * nodes ≈ ones(N)
        @test D * exp.(nodes) ≈ exp.(nodes)
        M = mass_matrix(D)
        @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
    end

    # test non-equidistant nodes generated by `nodes = [0.0, rand(8)..., 1.0]`
    nodes = [0.0, 0.01585580467018155, 0.18010381213204507, 0.270467434432868,
        0.37699483985320303, 0.5600831197666554, 0.5698824835924449, 0.623949064816263,
        0.8574665549914025, 1.0]
    N = length(nodes)
    let basis_functions = [one, identity, exp]
        D = function_space_operator(basis_functions, nodes, source)

        @test grid(D) ≈ nodes
        @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-11))
        @test D * nodes ≈ ones(N)
        @test D * exp.(nodes) ≈ exp.(nodes)
        M = mass_matrix(D)
        @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
    end
end
