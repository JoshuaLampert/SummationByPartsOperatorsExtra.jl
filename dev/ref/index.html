<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SummationByPartsOperatorsExtra.jl</title><meta name="title" content="Reference · SummationByPartsOperatorsExtra.jl"/><meta property="og:title" content="Reference · SummationByPartsOperatorsExtra.jl"/><meta property="twitter:title" content="Reference · SummationByPartsOperatorsExtra.jl"/><meta name="description" content="Documentation for SummationByPartsOperatorsExtra.jl."/><meta property="og:description" content="Documentation for SummationByPartsOperatorsExtra.jl."/><meta property="twitter:description" content="Documentation for SummationByPartsOperatorsExtra.jl."/><meta property="og:url" content="https://JoshuaLampert.github.io/SummationByPartsOperatorsExtra.jl/stable/ref/"/><meta property="twitter:url" content="https://JoshuaLampert.github.io/SummationByPartsOperatorsExtra.jl/stable/ref/"/><link rel="canonical" href="https://JoshuaLampert.github.io/SummationByPartsOperatorsExtra.jl/stable/ref/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperatorsExtra.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../development/">Development</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/main/docs/src/ref.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SummationByPartsOperatorsExtra.jl-API"><a class="docs-heading-anchor" href="#SummationByPartsOperatorsExtra.jl-API">SummationByPartsOperatorsExtra.jl API</a><a id="SummationByPartsOperatorsExtra.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#SummationByPartsOperatorsExtra.jl-API" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.SummationByPartsOperatorsExtra"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.SummationByPartsOperatorsExtra"><code>SummationByPartsOperatorsExtra.SummationByPartsOperatorsExtra</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">SummationByPartsOperatorsExtra</code></pre><p><strong>SummationByPartsOperatorsExtra.jl</strong> is a <a href="https://julialang.org/">Julia</a> package that implements some extra functionality for the package <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a>. SummationByPartsOperatorsExtra.jl is still in an early stage of development and is meant to be used for research purposes. Maybe some parts of the package will be moved to SummationByPartsOperators.jl in the future. Until now, the package focuses on the implementation of function space summation-by-parts operators in one and multiple dimensions and on subcell summation-by-parts operators.</p><p>See also: <a href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl">SummationByPartsOperatorsExtra.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/SummationByPartsOperatorsExtra.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.AnalysisCallback"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.AnalysisCallback"><code>SummationByPartsOperatorsExtra.AnalysisCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AnalysisCallback(semi; interval = 0, dt = nothing)</code></pre><p>Analyze the numerical solution either every <code>interval</code> accepted time steps or every <code>dt</code> in terms of integration time. You can only pass either <code>interval</code> or <code>dt</code>, but not both at the same time. The analyzed quantities are computed by <code>analyze_quantities</code> defined for each equation type. The resulting quantities can be accessed via the <a href="#SummationByPartsOperatorsExtra.quantities-Tuple{DiscreteCallback{&lt;:Any, &lt;:AnalysisCallback}}"><code>quantities</code></a> function, and the corresponding time values via the <a href="#SummationByPartsOperatorsExtra.tstops-Tuple{DiscreteCallback{&lt;:Any, &lt;:AnalysisCallback}}"><code>tstops</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/conservation_laws/analysis_callback.jl#L9-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Basic"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Basic"><code>SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Basic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlaubitzIskeLampertÖffner2026Basic()</code></pre><p>Function space SBP operators constructed with optimization procedure given in</p><ul><li>Glaubitz, Iske, Lampert, Öffner (2026): Why summation by parts is not enough. <a href="https://arxiv.org/abs/2602.10786">arXiv:2602.10786</a></li></ul><p>See <a href="#SummationByPartsOperatorsExtra.function_space_operator"><code>function_space_operator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/function_space_operators.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026EigenvalueProperty"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026EigenvalueProperty"><code>SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026EigenvalueProperty</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlaubitzIskeLampertÖffner2026EigenvalueProperty()</code></pre><p>Function space SBP operators constructed with constrained optimization procedure satisfying an eigenvalue property given in</p><ul><li>Glaubitz, Iske, Lampert, Öffner (2026): Why summation by parts is not enough. <a href="https://arxiv.org/abs/2602.10786">arXiv:2602.10786</a></li></ul><p>See <a href="#SummationByPartsOperatorsExtra.function_space_operator"><code>function_space_operator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/function_space_operators.jl#L47-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Multidimensional"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Multidimensional"><code>SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Multidimensional</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlaubitzIskeLampertÖffner2026Multidimensional()</code></pre><p>Multidimensional function space SBP (MFSBP) operators given in</p><ul><li>Glaubitz, Iske, Lampert, Öffner (2026) Efficient construction and application of multi-dimensional summation-by-parts operators to global radial basis function methods TODO</li></ul><p>See <a href="#SummationByPartsOperatorsExtra.multidimensional_function_space_operator"><code>multidimensional_function_space_operator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/multidimensional_function_space_operators.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Regularized"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Regularized"><code>SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Regularized</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlaubitzIskeLampertÖffner2026Regularized()</code></pre><p>Function space SBP operators constructed with regularized constrained optimization procedure given in</p><ul><li>Glaubitz, Iske, Lampert, Öffner (2026): Why summation by parts is not enough. <a href="https://arxiv.org/abs/2602.10786">arXiv:2602.10786</a></li></ul><p>See <a href="#SummationByPartsOperatorsExtra.function_space_operator"><code>function_space_operator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/function_space_operators.jl#L24-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.GlaubitzLampertWintersNordström2025"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.GlaubitzLampertWintersNordström2025"><code>SummationByPartsOperatorsExtra.GlaubitzLampertWintersNordström2025</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlaubitzLampertWintersNordström2025()</code></pre><p>Sub-cell SBP operators given in</p><ul><li>Glaubitz, Lampert, Winters, Nordström (2025): Towards provable energy-stable overset grid methods using sub-cell summation-by-parts operators. <a href="https://arxiv.org/abs/2509.21442">arXiv:2509.21442</a></li></ul><p>See <a href="#SummationByPartsOperatorsExtra.subcell_operator"><code>subcell_operator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L402-L412">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.MultidimensionalLinearAdvectionNonperiodicSemidiscretization"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.MultidimensionalLinearAdvectionNonperiodicSemidiscretization"><code>SummationByPartsOperatorsExtra.MultidimensionalLinearAdvectionNonperiodicSemidiscretization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultidimensionalLinearAdvectionNonperiodicSemidiscretization(D, a, bc)</code></pre><p>A semidiscretization of the linear advection equation     <span>$\partial_t u(x, t) + a\cdot \nabla u(x, t) = 0$</span> with boundary conditions <code>bc(x, t)</code>.</p><p><code>D</code> is a multidimensional SBP derivative operator, and <code>a</code> is a tuple of the constant coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/conservation_laws/multidimensional_linear_advection.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.PolynomialBasesDerivativeOperator"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.PolynomialBasesDerivativeOperator"><code>SummationByPartsOperatorsExtra.PolynomialBasesDerivativeOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolynomialBasesDerivativeOperator{T&lt;:Real, BasisType &lt;: NodalBasis{PolynomialBases.Line}}</code></pre><p>A derivative operator on a nonperiodic grid with scalar type <code>T</code> based on a basis from PolynomialBases.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/polynomialbases_operators.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.PolynomialBasesDerivativeOperator-Union{Tuple{T}, Tuple{Any, T, T, Int64}} where T&lt;:Real"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.PolynomialBasesDerivativeOperator-Union{Tuple{T}, Tuple{Any, T, T, Int64}} where T&lt;:Real"><code>SummationByPartsOperatorsExtra.PolynomialBasesDerivativeOperator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PolynomialBasesDerivativeOperator(basis_type, xmin::T, xmax::T, N::Int) where {T&lt;:Real}</code></pre><p>Construct the <code>PolynomialBasesDerivativeOperator</code> on a grid between <code>xmin</code> and <code>xmax</code> using <code>N</code> nodes and <code>N-1</code> modes defined by <code>basis_type</code> from PolynomialBases.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/polynomialbases_operators.jl#L33-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.SubcellOperator"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.SubcellOperator"><code>SummationByPartsOperatorsExtra.SubcellOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SubcellOperator{T}
SubcellOperator(nodes::Vector{T}, x_M::T,
                weights_left::Vector{T}, weights_right::Vector{T},
                Q_left::QType, Q_right::QType,
                B_left::BType, B_right::BType,
                accuracy_order::Int,
                source::SourceOfCoefficients) where {T &lt;: Real,
                                                     QType &lt;: AbstractMatrix{T},
                                                     BType &lt;: AbstractMatrix{T},
                                                     SourceOfCoefficients}</code></pre><p>A sub-cell derivative operator on a non-periodic grid with scalar type <code>T</code>. A sub-cell operator consists of two parts, a left and a right part, which are defined on the left and right sub-cells of the grid. Each of the two parts satisfy a summation-by-parts property on their respecting sub-cell. The whole operator satisfies a summation-by-parts property on the whole grid.</p><p>The whole operator follows the general interface of a derivative operator, e.g., implementing matrix-vector multiplication, integration, and the mass matrix. To obtain the derivative matrix <span>$D = P^{-1}(Q_L + Q_R)$</span> associated to the sub-cell operator, use the function <a href="#PolynomialBases.derivative_matrix-Tuple{SubcellOperator}"><code>derivative_matrix</code></a> or <code>Matrix</code>. The left and right mass matrices can be obtained with the functions <a href="#SummationByPartsOperatorsExtra.mass_matrix_left-Tuple{SubcellOperator}"><code>mass_matrix_left</code></a> and <a href="#SummationByPartsOperatorsExtra.mass_matrix_right-Tuple{SubcellOperator}"><code>mass_matrix_right</code></a>, respectively. Similarly, the boundary mass matrices can be obtained with the functions <a href="#SummationByPartsOperatorsExtra.mass_matrix_boundary_left-Tuple{SubcellOperator}"><code>mass_matrix_boundary_left</code></a> and <a href="#SummationByPartsOperatorsExtra.mass_matrix_boundary_right-Tuple{SubcellOperator}"><code>mass_matrix_boundary_right</code></a>.</p><p>See also <a href="#SummationByPartsOperatorsExtra.subcell_operator"><code>subcell_operator</code></a> and <a href="#SummationByPartsOperatorsExtra.GlaubitzLampertWintersNordström2025"><code>GlaubitzLampertWintersNordström2025</code></a>.</p><p>References:</p><ul><li>Glaubitz, Lampert, Winters, Nordström (2025): Towards provable energy-stable overset grid methods using sub-cell summation-by-parts operators. <a href="https://arxiv.org/abs/2509.21442">arXiv:2509.21442</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L1-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PolynomialBases.derivative_matrix-Tuple{SubcellOperator}"><a class="docstring-binding" href="#PolynomialBases.derivative_matrix-Tuple{SubcellOperator}"><code>PolynomialBases.derivative_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">derivative_matrix(Dop::SubcellOperator)</code></pre><p>Returns the derivative matrix <span>$D = P^{-1}(Q_L + Q_R)$</span> associated to the sub-cell operator <code>Dop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L178-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.compute_moments_boundary-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.compute_moments_boundary-Tuple{Any, Any, Any}"><code>SummationByPartsOperatorsExtra.compute_moments_boundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_moments_boundary(functions, nodes, normals)
compute_moments_boundary(functions, D::AbstractDerivativeOperator)
compute_moments_boundary(functions, geometry::Meshes.Geometry)</code></pre><p>Compute the moments, i.e., the integrals of the product of two basis functions weighted by the normal direction of the direction. For each direction, it computes a <span>$K \times K$</span> matrix, where <span>$K$</span> is the number of <code>functions</code> and returns a tuple of these matrices. In one dimension, <code>nodes</code> and <code>normals</code> can be passed. You can also pass a derivative operator <code>D</code> or a <code>Geometry</code> object from Meshes.jl. Note that the latter is defined in a package extension of MeshIntegrals.jl and therefore requires loading that package before.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/moments.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.couple_subcell-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.couple_subcell-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}"><code>SummationByPartsOperatorsExtra.couple_subcell</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">couple_subcell(D_left::AbstractNonperiodicDerivativeOperator,
               D_right::AbstractNonperiodicDerivativeOperator,
               x_M, [coupling=Val(:no)])</code></pre><p>Construct a <a href="#SummationByPartsOperatorsExtra.SubcellOperator"><code>SubcellOperator</code></a> from two non-periodic derivative operators <code>D_left</code> and <code>D_right</code> from SummationByPartsOperators.jl. <code>D_left</code> is defined on the left sub-cell, which is the interval <span>$[x_L, x_M]$</span> and <code>D_right</code> is defined on the right sub-cell, which is the interval <span>$[x_M, x_R]$</span>, where <code>x_L</code> and <code>x_R</code> are the left and right boundaries of the grid of <code>D_left</code> and <code>D_right</code>, respectively. Note that <code>x_M</code> must be between the right boundary of <code>D_left</code> and the left boundary of <code>D_right</code>. If <code>coupling</code> is set to <code>Val(:no)</code>, the two operators are simply combined without any coupling at the interface <code>x_M</code>. If <code>coupling</code> is set to <code>Val(:central)</code>, <code>Val(:plus)</code>, or <code>Val(:minus)</code>, the two operators are coupled using a central, upwind, or downwind coupling, respectively, as described in Section 2.5 of Ranocha, Mitsotakis, Ketcheson (2021). In fact, the operators obtained are mathematically the same as obtained by using <code>couple_discontinuously</code> with two elements, but here in the context of sub-cell operators. However, this implementation allows for different left and right operators, which is not possible with <code>couple_discontinuously</code>. Therefore, the mesh also does not need to be homogeneous.</p><p>See also <a href="#SummationByPartsOperatorsExtra.GlaubitzLampertWintersNordström2025"><code>GlaubitzLampertWintersNordström2025</code></a>.</p><ul><li>Ranocha, Mitsotakis, Ketcheson (2021). A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations. <a href="https://doi.org/10.4208/cicp.OA-2020-0119">DOI: 10.4208/cicp.OA-2020-0119</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L304-L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.function_space_operator"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.function_space_operator"><code>SummationByPartsOperatorsExtra.function_space_operator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function_space_operator(basis_functions, nodes, source;
                        derivative_order = 1, accuracy_order = 0,
                        basis_functions_weights = ones(length(basis_functions)),
                        regularization_functions = nothing,
                        min_real_eigen = 0.1,
                        bandwidth = length(nodes) - 1, size_boundary = 2 * bandwidth,
                        different_values = true, sparsity_pattern = nothing,
                        opt_alg = Optim.LBFGS(), options = Optim.Options(g_tol = 1e-14, iterations = 10000),
                        autodiff = ADTypes.AutoForwardDiff(), x0 = nothing, verbose = false)</code></pre><p>Construct an operator that represents a first-derivative operator in a function space spanned by the <code>basis_functions</code>, which is an iterable of functions. The operator is constructed on the interval <code>[x_min, x_max]</code> with the nodes <code>nodes</code>, where <code>x_min</code> is taken as the minimal value in <code>nodes</code> and <code>x_max</code> the maximal value. Note that the <code>nodes</code> will be sorted internally. The <code>accuracy_order</code> is the order of the accuracy of the operator, which can optionally be passed, but does not have any effect on the operator.</p><p>The operator is constructed solving an optimization problem with <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> for the source <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.GlaubitzNordstr%C3%B6m%C3%96ffner2023"><code>SummationByPartsOperators.GlaubitzNordströmÖffner2023</code></a> and using <a href="https://github.com/JuliaManifolds/Manopt.jl">Manopt.jl</a> for the sources <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Basic"><code>GlaubitzIskeLampertÖffner2026Basic</code></a>, <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Regularized"><code>GlaubitzIskeLampertÖffner2026Regularized</code></a>, and <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026EigenvalueProperty"><code>GlaubitzIskeLampertÖffner2026EigenvalueProperty</code></a>. You can specify the optimization algorithm, the options for the optimization problem, and the <code>autodiff</code> mode with the keyword arguments <code>opt_alg</code>, <code>options</code>, and <code>autodiff</code> respectively, see also the documentation of Optim.jl about <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/">configurable options</a> and <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/gradientsandhessians/#Automatic-differentiation">automatic differentiation</a> or of Manopt.jl about <a href="https://manoptjl.org/stable/solvers/augmented_Lagrangian_method/#Manopt.augmented_Lagrangian_method">algorithm options for, e.g., <code>augmented_Lagrangian_method</code></a> or <a href="https://manoptjl.org/stable/tutorials/HowToDebug/"><code>debug</code> output</a>. For higher number of nodes, reverse mode automatic differentiation is usually significantly faster than forward mode. We recommend using <code>autodiff = ADTypes.AutoMooncake(; config = nothing)</code> or <code>autodiff = ADTypes.AutoEnzyme(; mode = Enzyme.Reverse, function_annotation = Enzyme.Duplicated)</code>. Note that you need to import the package ADTypes.jl as well as the corresponding autodiff (i.e., Mooncake.jl or Enzyme.jl) package to use these modes. Both Optim.jl and Manopt.jl support <code>autodiff</code> backends via ADTypes.jl.</p><p>The initial guess for the optimization problem can be passed with the keyword argument <code>x0</code>, which is optional. If <code>nothing</code> is passed, a default initial guess (zeros for the entries of the differentiation matrix and equal values for all the weights) is used.</p><p>You can weight each basis function with the keyword argument <code>basis_functions_weights</code>, which is a vector of weights for each basis function. The default is a vector of ones, which means that all basis functions are equally weighted. This can be used to, e.g., enforce exactness for certain basis functions (high weights), but allow non-exactness for others only minimizing the error (low weights).</p><p>When using the source <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.GlaubitzNordstr%C3%B6m%C3%96ffner2023"><code>SummationByPartsOperators.GlaubitzNordströmÖffner2023</code></a> there are two alternative ways to enforce sparsity of the resulting operator.</p><p>The first is by passing a matrix <code>sparsity_pattern</code> that is a matrix of zeros and ones, where the ones indicate the non-zero entries of the operator. This matrix should be symmetric or <code>UpperTriangular</code> and have zeros on the diagonal.</p><p>The second way is to use a banded-block structure for the operator as is common, e.g., in finite difference methods. The keyword arguments <code>bandwidth</code> and <code>size_boundary</code> specify the bandwidth and the size of the boundary blocks of the operator, where the default of <code>bandwidth</code> is set to <code>length(nodes) - 1</code>, i.e., a dense operator (in this case <code>size_boundary</code> is ignored). To construct a sparse operator, you can set the bandwidth to a smaller value, such that <code>2 * size_boundary + bandwidth &lt; length(nodes)</code>, which is a requirement for the boundary blocks in the upper left and lower right of the resulting operator. If <code>different_values</code> is set to <code>true</code> all the entries in the upper right triangle of S (the skew symmetric part of D) are different, which is generally meaningful for non-equidistant nodes and general bases, if it is <code>false</code> the entries of the stencil are repeated in the central part and the two boundary closures share their values (makes sense for uniformly distributed nodes and, e.g., a polynomial basis). The keyword argument <code>different_values</code> is ignored for dense operators.</p><p>When using the regularized optimization procedure using <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Regularized"><code>GlaubitzIskeLampertÖffner2026Regularized</code></a>, you have to pass additional functions to be regularized with the keyword argument <code>regularization_functions</code>, which is an iterable of functions.</p><p>When using the optimization procedure with eigenvalue constraint using <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026EigenvalueProperty"><code>GlaubitzIskeLampertÖffner2026EigenvalueProperty</code></a>, you can specify the minimal real part of the eigenvalues of the resulting operator with the keyword argument <code>min_real_eigen</code>.</p><p>The keyword argument <code>verbose</code> can be set to <code>true</code> to print information about the optimization process.</p><p>The operator that is returned follows the general interface. Currently, it is wrapped in a <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.MatrixDerivativeOperator"><code>SummationByPartsOperators.MatrixDerivativeOperator</code></a>, but this might change in the future.</p><p>In order to use this function, either the packages Optim.jl and ForwardDiff.jl (for <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.GlaubitzNordstr%C3%B6m%C3%96ffner2023"><code>SummationByPartsOperators.GlaubitzNordströmÖffner2023</code></a>) or Manifolds.jl, Manopt.jl, and ForwardDiff.jl (for <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Basic"><code>GlaubitzIskeLampertÖffner2026Basic</code></a>, <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Regularized"><code>GlaubitzIskeLampertÖffner2026Regularized</code></a>, and <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026EigenvalueProperty"><code>GlaubitzIskeLampertÖffner2026EigenvalueProperty</code></a>) must be loaded.</p><p>See also <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.GlaubitzNordstr%C3%B6m%C3%96ffner2023"><code>SummationByPartsOperators.GlaubitzNordströmÖffner2023</code></a>, <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Basic"><code>GlaubitzIskeLampertÖffner2026Basic</code></a>, <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Regularized"><code>GlaubitzIskeLampertÖffner2026Regularized</code></a>, and <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026EigenvalueProperty"><code>GlaubitzIskeLampertÖffner2026EigenvalueProperty</code></a>.</p><div class="admonition is-warning" id="Experimental-implementation-8fbca5544f51bfc8"><header class="admonition-header">Experimental implementation<a class="admonition-anchor" href="#Experimental-implementation-8fbca5544f51bfc8" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/function_space_operators.jl#L72-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.get_multidimensional_optimization_entries-Tuple{Any}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.get_multidimensional_optimization_entries-Tuple{Any}"><code>SummationByPartsOperatorsExtra.get_multidimensional_optimization_entries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_multidimensional_optimization_entries(D;
                                          bandwidth = div(accuracy_order(D), 2),
                                          size_boundary = SummationByPartsOperators.lower_bandwidth(D) + 1,
                                          different_values = false,
                                          sparsity_pattern = nothing)</code></pre><p>Get the entries to optimize for in an optimization-based construction procedure of multidimensional summation-by-parts operators from a derivative operator <code>D</code>. It contains the entries of the skew-symmetric part of the operator <span>$D$</span>, the entries of the diagonal mass matrix <span>$M$</span>, and the entries of the diagonal boundary mass matrix. For more details, see <a href="#SummationByPartsOperatorsExtra.multidimensional_function_space_operator"><code>multidimensional_function_space_operator</code></a>. The output can be passed as initial values to the optimization problem as <code>x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/optimization.jl#L202-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.get_nsigma-Tuple{Any}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.get_nsigma-Tuple{Any}"><code>SummationByPartsOperatorsExtra.get_nsigma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nsigma(N; bandwidth = N - 1,
           size_boundary = 2 * bandwidth, different_values = true,
           sparsity_pattern = nothing)</code></pre><p>Get the number of unique non-zero entries in a skew-symmetric matrix. If <code>bandwidth</code> is <code>N - 1</code>, the whole upper right triangle is used. If <code>bandwidth</code> is smaller, a block-banded structure with boundary blocks of size <code>size_boundary</code> is used and a banded matrix with bandwidth <code>bandwidth</code> in the middle. If <code>different_values</code> is <code>false</code>, the stencils are repeating. If <code>sparsity_pattern</code> is given, the number of non-zero entries in the sparsity pattern is returned. The sparsity pattern is assumed to be a <code>UpperTriangular</code> matrix with zeros on the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/optimization.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.get_optimization_entries-Tuple{Any}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.get_optimization_entries-Tuple{Any}"><code>SummationByPartsOperatorsExtra.get_optimization_entries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_optimization_entries(D;
                         bandwidth = div(accuracy_order(D), 2),
                         size_boundary = SummationByPartsOperators.lower_bandwidth(D) + 1,
                         different_values = false,
                         sparsity_pattern = nothing)</code></pre><p>Get the entries to optimize for in an optimization-based construction procedure of summation-by-parts operators from a derivative operator <code>D</code>. It contains the entries of the skew-symmetric part of the operator <code>D</code> and the entries of the diagonal mass matrix <code>M</code>. For more details, see <a href="#SummationByPartsOperatorsExtra.function_space_operator"><code>function_space_operator</code></a>. The output can be passed as initial values to the optimization problem as <code>x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/optimization.jl#L106-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.get_sparsity_pattern-Tuple{Any}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.get_sparsity_pattern-Tuple{Any}"><code>SummationByPartsOperatorsExtra.get_sparsity_pattern</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_sparsity_pattern(S)
get_sparsity_pattern(D::AbstractNonperiodicDerivativeOperator)
get_sparsity_pattern(D::AbstractMultidimensionalMatrixDerivativeOperator{2})</code></pre><p>If <code>S</code> is a (skew-symmetric) matrix, this function returns the sparsity pattern of <code>S</code> as a <code>UpperTriangular</code> matrix. If <code>D</code> is a one-dimensional derivative operator, this function returns the sparsity pattern of the skew-symmetric part of <code>D</code>. If <code>D</code> is a two-dimensional derivative operator, this function returns a tuple of the sparsity patterns of the skew-symmetric parts of <code>D</code> in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/sparsity_patterns.jl#L15-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.grid_left-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.grid_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.grid_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grid_left(D::SubcellOperator)</code></pre><p>Returns the grid associated to the left part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L103-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.grid_right-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.grid_right-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.grid_right</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grid_right(D::SubcellOperator)</code></pre><p>Returns the grid associated to the right part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L109-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.left_projection_left-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.left_projection_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.left_projection_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">left_projection_left(D::SubcellOperator)</code></pre><p>Returns the left projection operator <span>$e_L$</span> associated to the left part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L153-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.left_projection_right-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.left_projection_right-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.left_projection_right</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">left_projection_right(D::SubcellOperator)</code></pre><p>Returns the right projection operator <span>$e_{M_L}$</span> associated to the left part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L159-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.mass_matrix_boundary_left-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.mass_matrix_boundary_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.mass_matrix_boundary_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mass_matrix_boundary_left(D::SubcellOperator)</code></pre><p>Returns the mass matrix associated to the left boundary of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L138-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.mass_matrix_boundary_right-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.mass_matrix_boundary_right-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.mass_matrix_boundary_right</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mass_matrix_boundary_right(D::SubcellOperator)</code></pre><p>Returns the mass matrix associated to the right boundary of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L144-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.mass_matrix_left-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.mass_matrix_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.mass_matrix_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mass_matrix_left(D::SubcellOperator)</code></pre><p>Returns the mass matrix associated to the left part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L124-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.mass_matrix_right-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.mass_matrix_right-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.mass_matrix_right</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mass_matrix_right(D::SubcellOperator)</code></pre><p>Returns the mass matrix associated to the right part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L130-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.multidimensional_function_space_operator"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.multidimensional_function_space_operator"><code>SummationByPartsOperatorsExtra.multidimensional_function_space_operator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multidimensional_function_space_operator(basis_functions, nodes, boundary_indices, normals, moments, vol, source;
                                         derivative_order = 1, accuracy_order = 0,
                                         bandwidth = length(nodes) - 1, size_boundary = 2 * bandwidth,
                                         different_values = true, sparsity_pattern = nothing,
                                         opt_alg = Optim.LBFGS(), options = Optim.Options(g_tol = 1e-14, iterations = 10000),
                                         autodiff = ADTypes.AutoForwardDiff(), x0 = nothing, verbose = false)</code></pre><p>Construct a <a href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/api_reference/#SummationByPartsOperators.MultidimensionalMatrixDerivativeOperator"><code>SummationByPartsOperators.MultidimensionalMatrixDerivativeOperator</code></a> that represents a first-derivative operator in a function space spanned by the <code>basis_functions</code>, which is an iterable of functions. The operator is constructed on the scattered nodes <code>nodes</code>. They should be provided as an iterable of <code>SVector{Dim, T}</code>. The <code>boundary_indices</code> is a vector of indies that indicates, which nodes are on the boundary. <code>normals</code> is a vector of <code>SVector{Dim, T}</code> that contains the normal vectors of the boundary nodes. The <code>moments</code> are a <code>Tuple</code> of matrices that represent the moments of the basis functions in each direction. The total volume of the domain is given by <code>vol</code>.</p><p>The <code>accuracy_order</code> is the order of the accuracy of the operator, which can optionally be passed, but does not have any effect on the operator.</p><p>The operator is constructed solving an optimization problem with <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a>. You can specify the optimization algorithm, the options for the optimization problem, and the <code>autodiff</code> mode with the keyword arguments <code>opt_alg</code>, <code>options</code>, and <code>autodiff</code> respectively, see also the documentation of Optim.jl about <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/">configurable options</a> and <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/gradientsandhessians/#Automatic-differentiation">automatic differentiation</a>. In this case, reverse mode automatic differentiation is usually significantly faster than forward mode. We recommend using <code>autodiff = ADTypes.AutoMooncake(; config = nothing)</code> or <code>autodiff = ADTypes.AutoEnzyme(; mode = Enzyme.Reverse, function_annotation = Enzyme.Duplicated)</code>. Note that you need to import the package ADTypes.jl as well as the corresponding autodiff (i.e., Mooncake.jl or Enzyme.jl) package to use these modes.</p><p>The initial guess for the optimization problem can be passed with the keyword argument <code>x0</code>, which is optional. If <code>nothing</code> is passed, a default initial guess (zeros for the entries of the differentiation matrix and equal values for all the weights and boundary weights) is used.</p><p>There are two alternative ways to enforce sparsity of the resulting operator. The first is by passing a matrix <code>sparsity_pattern</code> that is a matrix of zeros and ones, where the ones indicate the non-zero entries of the operator. This matrix should be symmetric or <code>UpperTriangular</code> and have zeros on the diagonal.</p><p>The second way is to use a banded-block structure for the operator as is common, e.g., in finite difference methods. The keyword arguments <code>bandwidth</code> and <code>size_boundary</code> specify the bandwidth and the size of the boundary blocks of the differentiation matrices in each direction, where the default of <code>bandwidth</code> is set to <code>length(nodes) - 1</code>, i.e., dense operators (in this case <code>size_boundary</code> is ignored). To construct sparse operators, you can set the bandwidth to a smaller value, such that <code>2 * size_boundary + bandwidth &lt; length(nodes)</code>, which is a requirement for the boundary blocks in the upper left and lower right of the resulting operator. If <code>different_values</code> is set to <code>true</code> all the entries in the upper right triangle of all matrices S (the skew symmetric parts of the differentiation matrices D) are different, which is generally meaningful for non-equidistant nodes and general bases, if it is <code>false</code> the entries of the stencil are repeated in the central part and the two boundary closures share their values (makes sense for uniformly distributed nodes and, e.g., a polynomial basis). The keyword argument <code>different_values</code> is ignored for dense operators. The parameters <code>bandwidth</code>, <code>size_boundary</code>, and <code>different_values</code> are only used if <code>sparsity_pattern</code> is not provided.</p><p>The keyword argument <code>verbose</code> can be set to <code>true</code> to print information about the optimization process.</p><p>In order to use this function, the packages Optim.jl and ForwardDiff.jl must be loaded.</p><p>See also <a href="#SummationByPartsOperatorsExtra.GlaubitzIskeLampertÖffner2026Multidimensional"><code>GlaubitzIskeLampertÖffner2026Multidimensional</code></a>.</p><div class="admonition is-warning" id="Experimental-implementation-8fbca5544f51bfc8"><header class="admonition-header">Experimental implementation<a class="admonition-anchor" href="#Experimental-implementation-8fbca5544f51bfc8" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/multidimensional_function_space_operators.jl#L27-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.neighborhood_sparsity_pattern-Tuple{Any, Any}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.neighborhood_sparsity_pattern-Tuple{Any, Any}"><code>SummationByPartsOperatorsExtra.neighborhood_sparsity_pattern</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighborhood_sparsity_pattern(nodes, lengths)</code></pre><p>For a given set of <code>nodes</code> in a multi-dimensional space, this function computes the sparsity pattern of the differentiation matrices, which only includes non-zero entries at nodes, which are within a certain ellipsoid neighborhood. <code>lengths</code> is a tuple of length <code>d</code> (dimension) representing the lengths of an ellipsoid indicating, which nodes are counted as neighbors. For example, for a differentiation matrix in x direction, it makes sense to use a larger length in x direction than in y direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/sparsity_patterns.jl#L37-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.plot_nodes"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.plot_nodes"><code>SummationByPartsOperatorsExtra.plot_nodes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_nodes(nodes_inner, nodes_boundary; corners = nothing, kwargs...)
plot_nodes(nodes, boundary_indices::Vector{Int}; corner_indices = nothing,
           kwargs...)
plot_nodes(D; kwargs...)</code></pre><p>Plot the nodes of a multidimensional derivative operator <code>D</code>. The interior nodes <code>nodes_inner</code> are plotted and the boundary nodes <code>nodes_boundary</code> are plotted in different colors. If <code>corner_indices</code> are provided, the corners are also plotted in a different color. Additional keyword arguments are passed to <code>viz</code> from Meshes.jl, see <a href="https://juliageometry.github.io/MeshesDocs/stable/visualization/">the documentation</a>. The function returns the current figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/visualization.jl#L2-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.plot_normals"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.plot_normals"><code>SummationByPartsOperatorsExtra.plot_normals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_normals(nodes_boundary, normals; kwargs...)
plot_normals(D; kwargs...)</code></pre><p>Plot the normals of a multidimensional derivative operator <code>D</code>. The boundary nodes <code>nodes_boundary</code> are plotted and the normals are plotted as arrows. Additional keyword arguments are passed to <code>viz</code> from Meshes.jl, see <a href="https://juliageometry.github.io/MeshesDocs/stable/visualization/">the documentation</a>. The function returns the current figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/visualization.jl#L15-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.plot_sparsity_pattern"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.plot_sparsity_pattern"><code>SummationByPartsOperatorsExtra.plot_sparsity_pattern</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_sparsity_pattern(sparsity_pattern, nodes, node_index)</code></pre><p>Plot the <code>sparsity_pattern</code>, which is a boolean matrix of length <code>length(nodes) x length(nodes)</code>, where <code>nodes</code> is a set of nodes. The <code>node_index</code> is the index of the node in <code>nodes</code> that is used to plot the sparsity pattern around that node, i.e., it will be plotted as red, while all neighboring nodes according to the <code>sparsity_pattern</code> are plotted as green dots and the remaining nodes are plotted as blue dots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/utils/visualization.jl#L25-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.polynomialbases_derivative_operator-Tuple{Any, Real, Real, Integer}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.polynomialbases_derivative_operator-Tuple{Any, Real, Real, Integer}"><code>SummationByPartsOperatorsExtra.polynomialbases_derivative_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polynomialbases_derivative_operator(basis_type, xmin::Real, xmax::Real, N::Integer)
polynomialbases_derivative_operator(basis_type; xmin::Real, xmax::Real, N::Integer)</code></pre><p>Construct the <code>PolynomialBasesDerivativeOperator</code> on a uniform grid between <code>xmin</code> and <code>xmax</code> using <code>N</code> nodes and <code>N-1</code> Legendre modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/polynomialbases_operators.jl#L48-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.quantities-Tuple{DiscreteCallback{&lt;:Any, &lt;:AnalysisCallback}}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.quantities-Tuple{DiscreteCallback{&lt;:Any, &lt;:AnalysisCallback}}"><code>SummationByPartsOperatorsExtra.quantities</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quantities(analysis_callback)</code></pre><p>Return the computed quantities for each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/conservation_laws/analysis_callback.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.right_projection_left-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.right_projection_left-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.right_projection_left</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">right_projection_left(D::SubcellOperator)</code></pre><p>Returns the left projection operator <span>$e_{M_R}$</span> associated to the right part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L165-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.right_projection_right-Tuple{SubcellOperator}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.right_projection_right-Tuple{SubcellOperator}"><code>SummationByPartsOperatorsExtra.right_projection_right</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">right_projection_right(D::SubcellOperator)</code></pre><p>Returns the right projection operator <span>$e_R$</span> associated to the right part of the sub-cell operator <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L171-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.subcell_operator"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.subcell_operator"><code>SummationByPartsOperatorsExtra.subcell_operator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subcell_operator(basis_functions, nodes, x_M, source;
                 derivative_order = 1, accuracy_order = 0,
                 bandwidths = [N_L - 1, N_R - 1], size_boundaries = 2 .* bandwidths,
                 different_values = [true, true], sparsity_patterns = [nothing, nothing],
                 M_local_approximation = [N_L, N_R],
                 opt_alg = Optim.LBFGS(), options = Optim.Options(g_tol = 1e-14, iterations = 10000),
                 autodiff = ADTypes.AutoForwardDiff(), x0 = nothing, verbose = false)</code></pre><p>Construct a sub-cell operator in a function space spanned by the <code>basis_functions</code>, which is an iterable of functions. The operator is constructed on the interval <code>[x_min, x_max]</code> with the nodes <code>nodes</code>, where <code>x_min</code> is taken as the minimal value in <code>nodes</code> and <code>x_max</code> the maximal value. Note that the <code>nodes</code> will be sorted internally. The left part of the sub-cell operator consists of the <code>nodes</code>, which are smaller than <code>x_M</code> and the right part of the <code>nodes</code>, which are bigger than <code>x_M</code>. The <code>accuracy_order</code> is the order of the accuracy of the operator, which can optionally be passed, but does not have any effect on the operator.</p><p>The operator is constructed solving an optimization problem with Optim.jl. You can specify the optimization algorithm, the options for the optimization problem, and the <code>autodiff</code> mode with the keyword arguments <code>opt_alg</code>, <code>options</code>, and <code>autodiff</code> respectively, see also the documentation of Optim.jl about <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/">configurable options</a> and <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/gradientsandhessians/#Automatic-differentiation">automatic differentiation</a>. In this case, reverse mode automatic differentiation is usually significantly faster than forward mode. We recommend using <code>autodiff = ADTypes.AutoMooncake(; config = nothing)</code> or <code>autodiff = ADTypes.AutoEnzyme(; mode = Enzyme.Reverse, function_annotation = Enzyme.Duplicated)</code>. Note that you need to import the package <code>ADTypes</code> as well as the corresponding autodiff (i.e., <code>Mooncake</code> or <code>Enzyme</code>) package to use these modes.</p><p>The initial guess for the optimization problem can be passed with the keyword argument <code>x0</code>, which is optional. If <code>nothing</code> is passed, a default initial guess (zeros for the entries of the differentiation matrix and equal values for all the weights) is used.</p><p>There are two alternative ways to enforce sparsity of the resulting left and right operator. The first is by passing matrices <code>sparsity_pattern</code> that are matrices of zeros and ones each, where the ones indicate the non-zero entries of the left and operator, respectively. The matrices should be symmetric or <code>UpperTriangular</code> and have zeros on the diagonal.</p><p>The second way is to use a banded-block structure for the parts of the operator as is common, e.g., in finite difference methods. The keyword arguments <code>bandwidths</code> and <code>size_boundaries</code> specify the bandwidth and the size of the boundary blocks of the operators, where the default of <code>bandwidths</code> is set to the number of nodes in the left and right sub-cell minus one, i.e., a dense operator (in this case <code>size_boundaries</code> is ignored). To construct a sparse operator, you can set the bandwidth to a smaller value, such that <code>2 * size_boundaries[i] + bandwidths[i] &lt; N_{L/R}</code>, which is a requirement for the boundary blocks in the upper left and lower right of the resulting operator. If <code>different_values</code> is set to <code>true</code> all the entries in the upper right triangle of S (the skew symmetric parts of the differentiation matrix blocks) are different, which is generally meaningful for non-equidistant nodes and general bases, if it is <code>false</code> the entries of the stencil are repeated in the central part and the two boundary closures share their values (makes sense for uniformly distributed nodes and, e.g., a polynomial basis). The keyword argument <code>different_values</code> is ignored for dense operators.</p><p>You can use the keyword argument <code>M_local_approximation</code> to specify the number of points used for local approximations of the discrete projections. The default is to use the number of nodes in the left and right sub-cell, respectively. To use an interpolation, you can set <code>M_local_approximation</code> to <code>[K, K]</code>, where <code>K</code> is the number of basis functions.</p><p>The keyword argument <code>verbose</code> can be set to <code>true</code> to print information about the optimization process.</p><p>Returns a <a href="#SummationByPartsOperatorsExtra.SubcellOperator"><code>SubcellOperator</code></a> object.</p><p>In order to use this function, the packages <code>Optim</code> and <code>ForwardDiff</code> must be loaded.</p><p>See also <a href="#SummationByPartsOperatorsExtra.GlaubitzLampertWintersNordström2025"><code>GlaubitzLampertWintersNordström2025</code></a>.</p><div class="admonition is-compat" id="Julia-1.9-3c38460828cacc54"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-3c38460828cacc54" title="Permalink"></a></header><div class="admonition-body"><p>This function requires at least Julia 1.9.</p></div></div><div class="admonition is-warning" id="Experimental-implementation-8fbca5544f51bfc8"><header class="admonition-header">Experimental implementation<a class="admonition-anchor" href="#Experimental-implementation-8fbca5544f51bfc8" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/subcell_operators.jl#L428-L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SummationByPartsOperatorsExtra.tstops-Tuple{DiscreteCallback{&lt;:Any, &lt;:AnalysisCallback}}"><a class="docstring-binding" href="#SummationByPartsOperatorsExtra.tstops-Tuple{DiscreteCallback{&lt;:Any, &lt;:AnalysisCallback}}"><code>SummationByPartsOperatorsExtra.tstops</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tstops(analysis_callback)</code></pre><p>Return the time values that correspond to the saved values of the <a href="#SummationByPartsOperatorsExtra.quantities-Tuple{DiscreteCallback{&lt;:Any, &lt;:AnalysisCallback}}"><code>quantities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaLampert/SummationByPartsOperatorsExtra.jl/blob/1b6841eba48822755dc6ea325992b61ea44d175b/src/conservation_laws/analysis_callback.jl#L61-L65">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../development/">« Development</a><a class="docs-footer-nextpage" href="../license/">License »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 12 February 2026 10:35">Thursday 12 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
